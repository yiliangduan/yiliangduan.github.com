<html>
  <head>
    <title>Unity Coroutine的实现原理 - elangduan</title>
    <link href='/images/fav.png' rel='shortcut icon'>
<link href='' rel='alternate' type='application/rss+xml'>
<link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/highlight.css">
<link rel="stylesheet" href="/css/responsive.css">
<script src="/js/jquery.js"></script>
<script src="/js/basics.js"></script>
<meta content='width=device-width, initial-scale=1.0, user-scalable=no' name='viewport'>
<meta content='text/html; charset=utf-8' http-equiv='content-type'>


  </head>
  <body>
    <header>
</header>

    <div id='container'>
      <div class='block'>
  
    <a class='main' href='/'>随笔</a>
  
    <a class='main' href='/reading'>阅读</a>
  
    <a class='main' href='/movie'>电影</a>
  
    <a class='main' href='https://www.cnblogs.com/elang'>博客</a>
  
    <a class='main' href='/about'>关于</a>
  
</div>

      <!-- <section class='paging'>
  
    <div class='left'>
      <a href='/2017/06/18/Unity脚本自动构建ipa包/'>
        ‹
      </a>
    </div>
  
  
    <div class='right'>
      <a href='/2017/05/10/OpenGL中Normal的变换矩阵的推导/'>
        ›
      </a>
    </div>
  
</section>
 -->
      <div class='content'>
        <section class='post'>
          <h1>
            <div class='date'>2017-05-25</div>
            Unity Coroutine的实现原理
          </h1>
          <p>在Unity中我经常用到Coroutine的功能，但是对于Coroutine一直有一些疑问没有得到答案，下面先上一个在项目里面经常使用Coroutine的场景的sample:</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TestCoroutine.cs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestCoroutine</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span> (<span class="params"></span>) </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        StartCoroutine(Test()); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> IEnumerator <span class="title">Test</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Debug.Log(gameObject.name);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">yield</span> return new <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">5</span></span>)</span>;</span><br><span class="line"></span><br><span class="line">        Debug.Log(transform.localPosition);</span><br><span class="line"></span><br><span class="line">        transform.localScale = Vector3.one;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>Test中yield语句调用之后为什么可以立即停止，等到 <em>WaitForSeconds</em> 的时候接着执行，这是怎么做到的？</p>
</li>
<li><p>Test的返回值是IEnumerator，但是函数内部的return用了yield来修饰，yield到底做了什么工作。</p>
</li>
</ul>
<p>针对第二个问题我找到了一个比较详细的<a href="https://stackoverflow.com/a/39496" target="_blank" rel="external">解释</a>, 里面有这样一段话:</p>
<blockquote>
<p>The yield keyword actually does quite a lot here. The function returns an object that implements the IEnumerable interface.</p>
</blockquote>
<p>相当于yield关键字会自动生成一个集成IEnumerable的对象,那么这个对象到底是什么样子呢? 首先使用ILSpy工具查看下这段代码代码的C#版本:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[DebuggerHidden]</span><br><span class="line">private IEnumerator Test()</span><br><span class="line">&#123;</span><br><span class="line">	TestCoroutine.&lt;Test&gt;c__Iterator0 &lt;Test&gt;c__Iterator = new TestCoroutine.&lt;Test&gt;c__Iterator0();</span><br><span class="line">	&lt;Test&gt;c__Iterator.$this = this;</span><br><span class="line">	return &lt;Test&gt;c__Iterator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到通过ILSpy解析之后Test方法已经完全变了，但是也验证了上面的说法。yield关键字会自动转换成一个IEnumerable的对象，这里自动生成了一个名字为TestCoroutine.{Test}c_Iterator0 的类，并且创建了这个类型的 {Test}c_Iterator 对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">代码里面名字是TestCoroutine.&lt;Test&gt;c_Iterator0,但是当前主题&lt;&gt;符号显示不正确，所以改成&#123;&#125;显示。下同</span><br></pre></td></tr></table></figure>
<p>那这个对象内部是怎样实现的呢？现在我们得看下TestCoroutine.{Test}c_Iterator0的实现了(这里方法自动加了DebuggerHidden属性，所以只能看IL版本的代码)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">//TestCoroutine.IL</span><br><span class="line">//整个类的代码比较多，这里只截取我们需要的代码</span><br><span class="line"></span><br><span class="line">.class public auto ansi beforefieldinit Test.TestCoroutine</span><br><span class="line">	extends [UnityEngine]UnityEngine.MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">	// 嵌套类型</span><br><span class="line">	.class nested private auto ansi sealed beforefieldinit &apos;&lt;Test&gt;c__Iterator0&apos;</span><br><span class="line">		extends [mscorlib]System.Object</span><br><span class="line">		implements [mscorlib]System.Collections.IEnumerator,</span><br><span class="line">		           [mscorlib]System.IDisposable,</span><br><span class="line">		           class [mscorlib]System.Collections.Generic.IEnumerator`1&lt;object&gt;</span><br><span class="line">	&#123;</span><br><span class="line">		.custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (</span><br><span class="line">			01 00 00 00</span><br><span class="line">		)</span><br><span class="line">		// 成员</span><br><span class="line">		.field assembly class Test.TestCoroutine $this</span><br><span class="line">		.field assembly object $current</span><br><span class="line">		.field assembly bool $disposing</span><br><span class="line">		.field assembly int32 $PC</span><br><span class="line"></span><br><span class="line">		.method public final hidebysig newslot virtual </span><br><span class="line">			instance bool MoveNext () cil managed </span><br><span class="line">		&#123;</span><br><span class="line">			// 方法起始 RVA 地址 0x3c7a8</span><br><span class="line">			// 方法起始地址（相对于文件绝对值：0x3aba8）</span><br><span class="line">			// 代码长度 144 (0x90)</span><br><span class="line">			.maxstack 2</span><br><span class="line">			.locals init (</span><br><span class="line">				[0] uint32</span><br><span class="line">			)</span><br><span class="line"></span><br><span class="line">			// 0x3ABB4: 02</span><br><span class="line">			IL_0000: ldarg.0</span><br><span class="line">			// 0x3ABB5: 7B C9 07 00 04</span><br><span class="line">			IL_0001: ldfld int32 Test.TestCoroutine/&apos;&lt;Test&gt;c__Iterator0&apos;::$PC</span><br><span class="line">			// 0x3ABBA: 0A</span><br><span class="line">			IL_0006: stloc.0</span><br><span class="line">			// 0x3ABBB: 02</span><br><span class="line">			IL_0007: ldarg.0</span><br><span class="line">			// 0x3ABBC: 15</span><br><span class="line">			IL_0008: ldc.i4.m1</span><br><span class="line">			// 0x3ABBD: 7D C9 07 00 04</span><br><span class="line">			IL_0009: stfld int32 Test.TestCoroutine/&apos;&lt;Test&gt;c__Iterator0&apos;::$PC</span><br><span class="line">			// 0x3ABC2: 06</span><br><span class="line">			IL_000e: ldloc.0</span><br><span class="line">			// 0x3ABC3: 45 02 00 00 00 05 00 00 00 3A 00 00 00</span><br><span class="line">			IL_000f: switch (IL_0021, IL_0056) // 分支，直接执行IL_0021(对应我们cs代码的WaitForSeconds之前的代码，IL_0056对应我们WaitForSeconds之后的代码)</span><br><span class="line"></span><br><span class="line">			// 0x3ABD0: 38 6B 00 00 00</span><br><span class="line">			IL_001c: br IL_008c</span><br><span class="line"></span><br><span class="line">			// 0x3ABD5: 00</span><br><span class="line">			IL_0021: nop</span><br><span class="line">			// 0x3ABD6: 02</span><br><span class="line">			IL_0022: ldarg.0</span><br><span class="line">			// 0x3ABD7: 7B C6 07 00 04</span><br><span class="line">			IL_0023: ldfld class Test.TestCoroutine Test.TestCoroutine/&apos;&lt;Test&gt;c__Iterator0&apos;::$this</span><br><span class="line">		</span><br><span class="line">			//这里做了 Debug.Log(gameObject.name);</span><br><span class="line">		</span><br><span class="line">			// 0x3ABEB: 02</span><br><span class="line">			IL_0037: ldarg.0</span><br><span class="line">			// 0x3ABEC: 73 1B 02 00 0A</span><br><span class="line">			IL_0038: newobj instance void [UnityEngine]UnityEngine.WaitForSeconds::.ctor(float32) //创建一个WaitForSeconds对象，引用会存放在栈顶。</span><br><span class="line">			// 0x3ABF1: 7D C7 07 00 04</span><br><span class="line">			IL_003d: stfld object Test.TestCoroutine/&apos;&lt;Test&gt;c__Iterator0&apos;::$current // 将栈顶的对象(WaitForSeconds)赋值给current变量</span><br><span class="line">			// 0x3ABF6: 02</span><br><span class="line">			IL_0042: ldarg.0 //载入第0个参数</span><br><span class="line">			// 0x3ABF7: 7B C8 07 00 04</span><br><span class="line">			IL_0043: ldfld bool Test.TestCoroutine/&apos;&lt;Test&gt;c__Iterator0&apos;::$disposing</span><br><span class="line">			// 0x3ABFC: 2D 07</span><br><span class="line">			IL_0048: brtrue.s IL_0051 //判断成员变量disposing是否为true，非空或者非0，如果是则跳转到IL_0051的地址</span><br><span class="line"></span><br><span class="line">			// 0x3ABFE: 02</span><br><span class="line">			IL_004a: ldarg.0</span><br><span class="line">			// 0x3ABFF: 17</span><br><span class="line">			IL_004b: ldc.i4.1 //载入值1入栈</span><br><span class="line">			// 0x3AC00: 7D C9 07 00 04</span><br><span class="line">			//把栈顶的值(现在是1)赋值给成员变量PC，这样的话下次调用MoveNext,在IL_000f处的switch的分支就会直接走IL_0056了</span><br><span class="line">			IL_004c: stfld int32 Test.TestCoroutine/&apos;&lt;Test&gt;c__Iterator0&apos;::$PC </span><br><span class="line"></span><br><span class="line">			// 0x3AC05: 38 38 00 00 00</span><br><span class="line">			IL_0051: br IL_008e //IL_008e在当前(MoveNext)函数结尾</span><br><span class="line"></span><br><span class="line">			// 0x3AC0A: 02</span><br><span class="line">			IL_0056: ldarg.0</span><br><span class="line">			// 0x3AC0B: 7B C6 07 00 04</span><br><span class="line">			IL_0057: ldfld class Test.TestCoroutine Test.TestCoroutine/&apos;&lt;Test&gt;c__Iterator0&apos;::$this</span><br><span class="line">			// 0x3AC10: 28 4E 01 00 0A</span><br><span class="line">			</span><br><span class="line">			//这里做了Debug.Log(transform.localPosition);</span><br><span class="line"></span><br><span class="line">        	//       transform.localScale = Vector3.one;</span><br><span class="line">			</span><br><span class="line">			// 0x3AC39: 02</span><br><span class="line">			IL_0085: ldarg.0</span><br><span class="line">			// 0x3AC3A: 15</span><br><span class="line">			IL_0086: ldc.i4.m1</span><br><span class="line">			// 0x3AC3B: 7D C9 07 00 04</span><br><span class="line">			IL_0087: stfld int32 Test.TestCoroutine/&apos;&lt;Test&gt;c__Iterator0&apos;::$PC</span><br><span class="line"></span><br><span class="line">			// 0x3AC40: 16</span><br><span class="line">			IL_008c: ldc.i4.0</span><br><span class="line">			// 0x3AC41: 2A</span><br><span class="line">			IL_008d: ret</span><br><span class="line"></span><br><span class="line">			// 0x3AC42: 17</span><br><span class="line">			IL_008e: ldc.i4.1 </span><br><span class="line">			// 0x3AC43: 2A</span><br><span class="line">			IL_008f: ret</span><br><span class="line">		&#125; // 方法 &apos;&lt;Test&gt;c__Iterator0&apos;::MoveNext 结束</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里只截取了MoveNext方法，因为这个方法里面包含了我们Sample中的Test函数的所有逻辑操作。这段代码我加了注释，通过看代码基本上已经解决了我的第一个疑惑了,下面再做一下分析。Sample中的方法Test在编译之后会转换成大概这个样子(只是模拟):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">private sealed class &lt;Test&gt;c__Iterator0 : IEnumerator, System.IDisposable</span><br><span class="line">&#123;</span><br><span class="line">	// 用来保存 创建的WaitForSeconds对象的，调用者会根据这个对象的条件是否满足来确定调用MoveNext</span><br><span class="line">	private object current;</span><br><span class="line">	</span><br><span class="line">	// 判断宿主对象是否已经被销毁了,这里就是那个发起StartCoroutine的那个MonoBehaviour对象 </span><br><span class="line">	private bool disposing; </span><br><span class="line">	</span><br><span class="line">	//保存MoveNext中调用的地址的,用这个来判断是执行yield之前的代码还是之后的代码</span><br><span class="line">	private int PC; </span><br><span class="line">	</span><br><span class="line">	private bool MoveNext()</span><br><span class="line">	&#123;</span><br><span class="line">		 switch(this.PC)</span><br><span class="line">		 &#123;</span><br><span class="line">		 case IL_0021:</span><br><span class="line">			&#123;</span><br><span class="line">				Debug.Log(gameObject.name);</span><br><span class="line"></span><br><span class="line">   		     	this.current = new WaitForSeconds();</span><br><span class="line">        	</span><br><span class="line">	        	PC = IL_0056;</span><br><span class="line">	        	</span><br><span class="line">	        	return true;</span><br><span class="line">			&#125;</span><br><span class="line">   </span><br><span class="line">		 case IL_0056:</span><br><span class="line">			&#123;</span><br><span class="line">				Debug.Log(transform.localPosition);</span><br><span class="line"></span><br><span class="line">				transform.localScale = Vector3.one;</span><br><span class="line">			&#125;</span><br><span class="line">		 &#125;</span><br><span class="line">		  </span><br><span class="line">        return false;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	object IEnumerator&lt;object&gt;.Current</span><br><span class="line">   &#123;</span><br><span class="line">		get</span><br><span class="line">		&#123;</span><br><span class="line">			return this.current;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里已经知道了yield关键字所做的操作了，那么现在来看看这个{Test}c_Iterator0对象是怎样被调用的。</p>
<p>首先我们看到我们的Sample中的代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StartCoroutine(Test());</span><br></pre></td></tr></table></figure>
<p>这说明创建的{Test}c_Iterator0对象传入的StartCoroutine方法中了，浏览了StartCoroutine的实现，这个方法直接绑定的C++层MonoBehaviour的StartCoroutine方法，这里简述下里面的实现(不贴Unity代码了):</p>
<ul>
<li>调用StartCoroutine方法，该方法会以传入的IEnumerator参数(这里是{Test}c_Iterator0对象)创建一个C++的Coroutine对象</li>
<li>这个对象保存会保存参数IEnumerator对象，并且会先获取出IEnuerator的MoveNext和Current方法。这两个方法也是IEunerator最关键的方法</li>
<li>创建好之后这个Coroutine对象会保存在MonoBehaviour一个成员变量List中，这样使得MonoBehaviour具备StopCoroutine功能，StopCoroutine能够找到对应Coroutine并停止</li>
<li>Coroutine对象会调用成员方法run，启动这个Coroutine</li>
</ul>
<p>这个步骤大概是这样的(代码只表现大概逻辑，不能正确执行):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// C#层IEnumerator被传入C++层的时候会被C++的类ScriptingObjectPtr封装并绑定</span><br><span class="line">ScriptingObjectPtr MonoBehaviour::StartCoroutine(ScriptingObjectPtr userCoroutine)</span><br><span class="line">&#123;</span><br><span class="line">	Coroutine* coroutine = new Coroutine ();</span><br><span class="line">	</span><br><span class="line">	//获取C#层对应的方法，拿到方法的地址。通过Mono就可以直接调用了</span><br><span class="line">	ScriptingMethodPtr moveNext =  scripting_object_get_virtual_method(userCoroutine, MONO_COMMON.IEnumerator_MoveNext, GetScriptingMethodRegistry());</span><br><span class="line">	ScriptingMethodPtr current = scripting_object_get_virtual_method(userCoroutine, MONO_COMMON.IEnumerator_Current, GetScriptingMethodRegistry());</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">	coroutine-&gt;SetMoveNextMethod(moveNext);</span><br><span class="line">	coroutine-&gt;SetCurrentMethod(current);</span><br><span class="line">	</span><br><span class="line">	coroutine-&gt;m_Behaviour = this;</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	m_ActiveCoroutines.push_back(coroutine); </span><br><span class="line">	</span><br><span class="line">	coroutine.Run();</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么现在生成了C++层的Coroutine对象了，再分析Coroutine现在作为执行者它是怎么实现的。Coroutine里面针对yield对象(Sample里面是WaitForSeconds)类型做了处理:</p>
<ul>
<li>WaitForSeconds</li>
<li>WaitForFixedUpdate</li>
<li>WaitForEndOfFrame</li>
<li>Coroutine (C#层)</li>
<li>WWW</li>
<li>AsyncOperation</li>
</ul>
<p>这些类型处理的方式是定义了一个类似定时调用的管理类DelayedCallManager。比如我的条件是WaitForSceonds(5), 那么Coroutine里面会创建一个CallDelayed，把时间设置魏5秒，然后DelayedCallManager的Update里面会直接算时间，到时间了就会回调Coroutine。WWW类型比较特殊它本身做了类似的处理，它提供了一个方法CallWhenDone，当它完成的时候直接回调Coroutine。</p>
<p>这个步骤大概是这样的(代码只表现大概逻辑，不能正确执行):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">//Coroutine.cpp</span><br><span class="line"></span><br><span class="line">// Run其实是一个递归的操作，在CallDelayed之后回调coroutineCallback里面会根据条件再次进入Run，</span><br><span class="line">// 直到MoveNext返回false，条件结束了。</span><br><span class="line">void Coroutine::Run (...)</span><br><span class="line">&#123;</span><br><span class="line">	//根据IEnumerator的特性，首先得调用下MoveNext，所以这里进入Run之后首先会调用一次MoveNext(), </span><br><span class="line">	//就是&lt;Test&gt;c__Iterator0的MoveNext。这样就给current赋值了</span><br><span class="line">	ScriptingInvocation invocation(MoveNext);</span><br><span class="line">	...</span><br><span class="line"> 	ScriptingObjectPtr monoWait = invocation.Invoke(&amp;exception)</span><br><span class="line">	</span><br><span class="line">	//调用Current</span><br><span class="line">	ScriptingInvocation invocation(Current);</span><br><span class="line">	...</span><br><span class="line"> 	ScriptingObjectPtr monoWait = invocation.Invoke(&amp;exception);</span><br><span class="line"> 	</span><br><span class="line"> 	</span><br><span class="line">	//可以在Sample里面看到Current函数在调用过第一次MoveNext之后被赋值为WaitForSeconds对象，</span><br><span class="line">	//所以这里waitClass就可以获取WaitForSeconds对象的等待时间了</span><br><span class="line">	ScriptingClassPtr waitClass = scripting_object_get_class (monoWait, GetScriptingTypeRegistry());</span><br><span class="line"></span><br><span class="line">	if (scripting_class_is_subclass_of (waitClass, classes.waitForSeconds))</span><br><span class="line">	&#123;</span><br><span class="line">		float waitTime = 0;//通过waitClass获取WaitForSeconds对象的等待时间</span><br><span class="line">		MarshallManagedStructIntoNative(monoWait, &amp;waitTime);</span><br><span class="line">	</span><br><span class="line">		// 这里添加到DelayedCallManager里面</span><br><span class="line">		// coroutineCallback里面处理了我们在一个方法里面多次yield return的操作，</span><br><span class="line">		// 这个方法里面会递归调用Run直到所有的操作处理完成</span><br><span class="line">		CallDelayed(coroutineCallback, monobehaviour, waitTime, , ,);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//DelayedCallManager.cpp</span><br><span class="line"></span><br><span class="line">void DelayedCallManager::Update()</span><br><span class="line">&#123;</span><br><span class="line">	float time = GetCurTime();</span><br><span class="line">	int frame = GetTimeManager().GetFrameCount();</span><br><span class="line">	</span><br><span class="line">	Container::iterator iterator = m_CallObjects.begin (); //m_CallObjects保存了所有注册的Coroutine对象</span><br><span class="line">	</span><br><span class="line">	// iterator-&gt;time 在注册的时候赋值是: 当前时间 + 等待的时间(new WaitForSeconds(5),那么就是5秒)</span><br><span class="line">	// iterator-&gt;time &lt;= time 这个条件判断了iterator的定时时间是否满足了</span><br><span class="line">	// 比如上面我们加入定义new WaitForSeconds(5)，</span><br><span class="line">	// 满足的条件时就当当前时间time要大于iterator满足的时间的时候，则进入这个while循环内</span><br><span class="line">	while (iterator !=  m_CallObjects.end () &amp;&amp; iterator-&gt;time &lt;= time) </span><br><span class="line">	&#123;</span><br><span class="line">		//判断帧是否满足,加入用到了new WaitForFixedUpdate()之类的</span><br><span class="line">		if (cb.timeStamp != m_TimeStamp &amp;&amp; cb.frame &lt;= frame) 		&#123;</span><br><span class="line">			//调用CoroutineCallback了</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他的的类型会直接在下一帧调用,比如yield return 0</p>
<p>整个过程粗略的看大概就是这个样子。上面的分析没有深入到每个条件判断之类的，但是已经够了解Coroutine的全貌了。有错误的地方欢迎指出来，非常感谢。</p>

          <!-- <br>
<p>Elang Duan</p>
<p><img src='/images/scribble3.png' alt='scribble'></p>
 -->
        </section>
      </div>
      
      <div class='block'>
  
    <a class='main' href='/'>随笔</a>
  
    <a class='main' href='/reading'>阅读</a>
  
    <a class='main' href='/movie'>电影</a>
  
    <a class='main' href='https://www.cnblogs.com/elang'>博客</a>
  
    <a class='main' href='/about'>关于</a>
  
</div>

    </div>
    <footer>
  <span class='muted'>&copy; elangduan@126.com</span>
  <a class='muted'>& powered by Hexo</a>
  <br>
  <br>

</footer>

  </body>
</html>
