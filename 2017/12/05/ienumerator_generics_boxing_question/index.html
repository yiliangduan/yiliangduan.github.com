<html>
  <head>
    <title>C# 泛型集合的Boxing问题 - elangduan</title>
    <link href='/images/fav.png' rel='shortcut icon'>
<link href='' rel='alternate' type='application/rss+xml'>
<link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/highlight.css">
<link rel="stylesheet" href="/css/responsive.css">
<script src="/js/jquery.js"></script>
<script src="/js/basics.js"></script>
<meta content='width=device-width, initial-scale=1.0, user-scalable=no' name='viewport'>
<meta content='text/html; charset=utf-8' http-equiv='content-type'>


  </head>
  <body>
    <header>
</header>

    <div id='container'>
      <div class='block'>
  
    <a class='main' href='/'>随笔</a>
  
    <a class='main' href='/reading'>阅读</a>
  
    <a class='main' href='/movie'>电影</a>
  
    <a class='main' href='/about'>关于</a>
  
</div>

      <!-- <section class='paging'>
  
    <div class='left'>
      <a href='/2017/12/09/ugui_graphics_rebuild_about_image_alpha_fade/'>
        ‹
      </a>
    </div>
  
  
    <div class='right'>
      <a href='/2017/12/03/optimizing_graphics_rendering_in_unity_games/'>
        ›
      </a>
    </div>
  
</section>
 -->
      <div class='content'>
        <section class='post'>
          <h1>
            <div class='date'>2017-12-05</div>
            C# 泛型集合的Boxing问题
          </h1>
          <p>今天检查项目中代码的Boxing问题的时候。有一个点当时让我困惑了不少时间。如下:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IEnumerator&lt;<span class="keyword">float</span>&gt; <span class="title">Func0</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">0.1</span>f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> IEnumerator <span class="title">Func1</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里在实际代码运行过程中Func1会产生Boxing而Func0没有产生Boxing，按照自己浏览的C#的文档对Boxing的理解这里应该都是会产生Boxing的才对。下面是<a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/boxing-and-unboxing" target="_blank" rel="external">C#的Boxing文档说明</a>的：</p>
<blockquote>
<p>Boxing is the process of converting a value type to the type object or to any interface type implemented by this value type. When the CLR boxes a value type, it wraps the value inside a System.Object and stores it on the managed heap. </p>
</blockquote>
<p>查看了IEnumerator<t>的定义:</t></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface IEnumerator&lt;T&gt; : IEnumerator, IDisposable</span><br><span class="line">&#123;</span><br><span class="line">  T Current &#123;<span class="keyword">get</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是interface类型，那么上面的函数中<em>yield return 0.1f</em>中的0.1f这个float类型的变量转换为IEnumerator<float>为什么不会Boxing呢? 先查看下两个方法的IL代码，对比下IL代码的区别。如下：</float></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于Func0</span></span><br><span class="line">.class nested <span class="keyword">private</span> auto ansi <span class="keyword">sealed</span> beforefieldinit <span class="string">'&lt;Func0&gt;c__Iterator0'</span></span><br><span class="line">	...</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// Fields</span></span><br><span class="line">	.field assembly float32 $current <span class="comment">//current编译成为了我们指定的float类型</span></span><br><span class="line">	.field assembly <span class="keyword">bool</span> $disposing</span><br><span class="line">	.field assembly int32 $PC	</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于Func1</span></span><br><span class="line">.class nested <span class="keyword">private</span> auto ansi <span class="keyword">sealed</span> beforefieldinit <span class="string">'&lt;Func1&gt;c__Iterator1'</span></span><br><span class="line">	...</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// Fields</span></span><br><span class="line">	.field assembly <span class="keyword">object</span> $current<span class="comment">//current编译成为了默认的object类型</span></span><br><span class="line">	.field assembly <span class="keyword">bool</span> $disposing</span><br><span class="line">	.field assembly int32 $PC</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么问题就很清楚了，Func0其实每次迭代的时候接收值的变量就是float类型(对应于IL的float32类型)的所以根本不需要转换类型。但是对于Func1函数，编译成IL代码存储当前值的变量是object类型的，所以当我们Func1中返回值为0的int类型时，这个int型的变量会被转换成object类型而导致Boxing。</p>
<p>其实正确的操作是先看<a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/" target="_blank" rel="external">C#关于泛型的文档</a>才对。不过现在看下也不迟。其中第一段就有如下描述:</p>
<blockquote>
<p>by using a generic type parameter T you can write a single class that other client code can use without incurring the cost or risk of runtime casts or boxing operations</p>
</blockquote>
<p>到这儿疑问就比较明确的解决了。</p>

          <!-- <br>
<p>Elang Duan</p>
<p><img src='/images/scribble3.png' alt='scribble'></p>
 -->
        </section>
      </div>
      
      <div class='block'>
  
    <a class='main' href='/'>随笔</a>
  
    <a class='main' href='/reading'>阅读</a>
  
    <a class='main' href='/movie'>电影</a>
  
    <a class='main' href='/about'>关于</a>
  
</div>

    </div>
    <footer>
  <span class='muted'>&copy; elangduan@126.com</span>
  <a class='muted'>& powered by Hexo</a>
  <br>
  <br>

</footer>

  </body>
</html>
